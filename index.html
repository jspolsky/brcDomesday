<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BRC Domesday - Camp Map Viewer</title>
    <link rel="stylesheet" href="style.css">
</head>

<body>
    <div id="mapContainer">
        <canvas id="mapCanvas"></canvas>
        <div id="loadingStatus">Loading camp data...</div>
    </div>

    <div id="controls">
        <div class="control-section">
            <h3>BRC Domesday - Camp Map Visualization</h3>
            <div id="stats">
                <span class="stats" id="outlinesCount">Camp Outlines: Loading...</span>
                <span class="stats" id="namesCount">Camp Names: Loading...</span>
                <span class="stats" id="coordinates">Mouse: --, --</span>
                <span class="stats" id="currentCamp">Camp: None</span>
                <span class="stats" id="diagnostic" style="color: red; display: none;"></span>
            </div>
        </div>

        <div class="control-section">
            <h3>Controls</h3>
            <button onclick="zoomToFit()">Zoom to Fit</button>
            <button onclick="toggleNames()">Toggle Names</button>
            <button onclick="toggleOutlines()">Toggle Outlines</button>
        </div>

        <div class="control-section">
            <h3>Legend</h3>
            <div style="display: flex; align-items: center; margin-bottom: 5px;">
                <div style="width: 20px; height: 3px; background-color: lightblue; margin-right: 10px;"></div>
                <span>Camp Outlines</span>
            </div>
            <div style="display: flex; align-items: center;">
                <div style="width: 20px; height: 1px; background-color: black; margin-right: 10px;"></div>
                <span>Camp Names (vector text)</span>
            </div>
        </div>
    </div>

    <script>
        // Canvas and rendering setup
        const canvas = document.getElementById('mapCanvas');
        const ctx = canvas.getContext('2d');
        const loadingStatus = document.getElementById('loadingStatus');

        // Data storage
        let campOutlines = null;
        let campNames = null;
        let showNames = true;
        let showOutlines = true;

        // Camp highlighting
        let highlightedCamp = null;
        let lastDiagnostic = '';

        // View settings
        let viewport = {
            centerX: -119.22, // Approximate center of Black Rock City
            centerY: 40.782,
            scale: 5000, // Adjust this for initial zoom level
            offsetX: 0,
            offsetY: 0
        };

        // Geographic bounds for Black Rock City area
        const BRC_BOUNDS = {
            minLon: -119.26,
            maxLon: -119.19,
            minLat: 40.78,
            maxLat: 40.79
        };

        // Resize canvas to match container
        function resizeCanvas() {
            const container = document.getElementById('mapContainer');
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            redraw();
        }

        // Convert geographic coordinates to canvas coordinates
        function geoToCanvas(lon, lat) {
            // Convert longitude/latitude to canvas coordinates
            // Account for the fact that latitude needs to be scaled differently due to Earth's projection
            const latScale = Math.cos(viewport.centerY * Math.PI / 180); // Mercator-like adjustment

            const x = canvas.width / 2 + (lon - viewport.centerX) * viewport.scale * latScale;
            const y = canvas.height / 2 - (lat - viewport.centerY) * viewport.scale;

            return { x, y };
        }

        // Convert canvas coordinates back to geographic coordinates
        function canvasToGeo(canvasX, canvasY) {
            const latScale = Math.cos(viewport.centerY * Math.PI / 180);

            const lon = viewport.centerX + (canvasX - canvas.width / 2) / (viewport.scale * latScale);
            const lat = viewport.centerY - (canvasY - canvas.height / 2) / viewport.scale;

            return { lon, lat };
        }

        // Point-in-polygon test using ray casting algorithm
        function isPointInPolygon(lon, lat, coordinates) {
            let inside = false;
            const x = lon;
            const y = lat;

            for (let i = 0, j = coordinates.length - 1; i < coordinates.length; j = i++) {
                const xi = coordinates[i][0];
                const yi = coordinates[i][1];
                const xj = coordinates[j][0];
                const yj = coordinates[j][1];

                if (((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi)) {
                    inside = !inside;
                }
            }

            return inside;
        }

        // Find which camp contains the given geographic coordinate (with diagnostics)
        function findCampAtLocation(lon, lat) {
            lastDiagnostic = ''; // Reset diagnostic message
            
            if (!campOutlines) {
                lastDiagnostic = 'No camp outline data loaded';
                return null;
            }

            let totalFeatures = 0;
            let lineStringFeatures = 0;
            let validLengthFeatures = 0;
            let closedPolygons = 0;
            let testedFeatures = [];

            for (const feature of campOutlines.features) {
                totalFeatures++;
                
                if (feature.geometry.type === 'LineString') {
                    lineStringFeatures++;
                    const coordinates = feature.geometry.coordinates;

                    // Check if the coordinates form a closed polygon
                    if (coordinates.length > 3) {
                        validLengthFeatures++;
                        const first = coordinates[0];
                        const last = coordinates[coordinates.length - 1];
                        const tolerance = 0.000001;
                        const isClosed = Math.abs(first[0] - last[0]) < tolerance &&
                            Math.abs(first[1] - last[1]) < tolerance;

                        if (isClosed) {
                            closedPolygons++;
                            
                            // Test if point is inside this polygon
                            if (isPointInPolygon(lon, lat, coordinates)) {
                                return feature; // Found it!
                            }
                            
                            // For debugging, track some tested features
                            if (testedFeatures.length < 3) {
                                const fid = feature.properties ? feature.properties.fid : 'unknown';
                                testedFeatures.push(fid);
                            }
                        }
                    }
                }
            }

            // Generate diagnostic message
            const parts = [];
            parts.push(`${totalFeatures} total features`);
            parts.push(`${lineStringFeatures} LineStrings`);
            parts.push(`${validLengthFeatures} valid length`);
            parts.push(`${closedPolygons} closed polygons`);
            
            if (testedFeatures.length > 0) {
                parts.push(`tested: ${testedFeatures.join(', ')}`);
            }
            
            lastDiagnostic = `No match found: ${parts.join(', ')}`;
            return null;
        }

        // Draw a LineString feature
        function drawLineString(coordinates, color, lineWidth = 1) {
            if (coordinates.length < 2) return;

            ctx.strokeStyle = color;
            ctx.lineWidth = lineWidth;
            ctx.beginPath();

            const startPoint = geoToCanvas(coordinates[0][0], coordinates[0][1]);
            ctx.moveTo(startPoint.x, startPoint.y);

            for (let i = 1; i < coordinates.length; i++) {
                const point = geoToCanvas(coordinates[i][0], coordinates[i][1]);
                ctx.lineTo(point.x, point.y);
            }

            ctx.stroke();
        }

        // Draw a filled polygon
        function fillPolygon(coordinates, color) {
            if (coordinates.length < 3) return;

            ctx.fillStyle = color;
            ctx.beginPath();

            const startPoint = geoToCanvas(coordinates[0][0], coordinates[0][1]);
            ctx.moveTo(startPoint.x, startPoint.y);

            for (let i = 1; i < coordinates.length; i++) {
                const point = geoToCanvas(coordinates[i][0], coordinates[i][1]);
                ctx.lineTo(point.x, point.y);
            }

            ctx.closePath();
            ctx.fill();
        }

        // Calculate the centroid (geometric center) of a polygon
        function calculateCentroid(coordinates) {
            if (coordinates.length === 0) return null;
            
            let sumLon = 0;
            let sumLat = 0;
            
            for (const coord of coordinates) {
                sumLon += coord[0];
                sumLat += coord[1];
            }
            
            return [sumLon / coordinates.length, sumLat / coordinates.length];
        }

        // Draw a star marker at a geographic location
        function drawStarMarker(lon, lat, color = 'red', size = 12) {
            const canvasPoint = geoToCanvas(lon, lat);
            
            // Only draw if the point is visible on canvas
            if (canvasPoint.x >= 0 && canvasPoint.x <= canvas.width && 
                canvasPoint.y >= 0 && canvasPoint.y <= canvas.height) {
                
                ctx.font = `${size}px Arial`;
                ctx.fillStyle = color;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('â­', canvasPoint.x, canvasPoint.y);
            }
        }

        // Render all data
        function redraw() {
            // Clear canvas
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw camp outlines in light blue
            if (campOutlines && showOutlines) {
                campOutlines.features.forEach(feature => {
                    if (feature.geometry.type === 'LineString') {
                        const coordinates = feature.geometry.coordinates;
                        
                        // Fill highlighted camp with yellow background
                        if (highlightedCamp && feature === highlightedCamp) {
                            fillPolygon(coordinates, 'rgba(255, 255, 0, 0.3)');
                        }

                        // Draw the outline
                        const color = (highlightedCamp && feature === highlightedCamp) ? 'orange' : 'lightblue';
                        const lineWidth = (highlightedCamp && feature === highlightedCamp) ? 3 : 2;
                        drawLineString(coordinates, color, lineWidth);
                    }
                });
            }

            // Mark unclosed polygons with red stars
            if (campOutlines && showOutlines) {
                campOutlines.features.forEach(feature => {
                    if (feature.geometry.type === 'LineString') {
                        const coordinates = feature.geometry.coordinates;
                        
                        // Check if this polygon is unclosed
                        if (coordinates.length > 3) {
                            const first = coordinates[0];
                            const last = coordinates[coordinates.length - 1];
                            const tolerance = 0.000001;
                            const isClosed = Math.abs(first[0] - last[0]) < tolerance &&
                                Math.abs(first[1] - last[1]) < tolerance;
                            
                            // If not closed, draw a red star at the centroid
                            if (!isClosed) {
                                const centroid = calculateCentroid(coordinates);
                                if (centroid) {
                                    drawStarMarker(centroid[0], centroid[1], 'red', 16);
                                }
                            }
                        }
                    }
                });
            }

            // Draw camp names in black
            if (campNames && showNames) {
                campNames.features.forEach(feature => {
                    if (feature.geometry.type === 'LineString') {
                        drawLineString(feature.geometry.coordinates, 'black', 1);
                    }
                });
            }
        }

        // Load GeoJSON data
        async function loadGeoJSON(url) {
            try {
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return await response.json();
            } catch (error) {
                console.error(`Failed to load ${url}:`, error);
                return null;
            }
        }

        // Initialize the application
        async function init() {
            loadingStatus.textContent = 'Loading camp outlines...';

            // Load camp outlines
            campOutlines = await loadGeoJSON('data/camp_outlines_2025.geojson');
            if (campOutlines) {
                document.getElementById('outlinesCount').textContent =
                    `Camp Outlines: ${campOutlines.features.length}`;
            }

            loadingStatus.textContent = 'Loading camp names...';

            // Load camp names (this is the large file, so it might take a moment)
            campNames = await loadGeoJSON('data/camp_names_2025.geojson');
            if (campNames) {
                document.getElementById('namesCount').textContent =
                    `Camp Names: ${campNames.features.length}`;
            }

            loadingStatus.style.display = 'none';

            // Initial render
            resizeCanvas();
            zoomToFit();
        }

        // Calculate bounds from actual data
        function calculateDataBounds() {
            let minLon = Infinity, maxLon = -Infinity;
            let minLat = Infinity, maxLat = -Infinity;

            // Check camp outlines
            if (campOutlines) {
                campOutlines.features.forEach(feature => {
                    if (feature.geometry.type === 'LineString') {
                        feature.geometry.coordinates.forEach(coord => {
                            const [lon, lat] = coord;
                            minLon = Math.min(minLon, lon);
                            maxLon = Math.max(maxLon, lon);
                            minLat = Math.min(minLat, lat);
                            maxLat = Math.max(maxLat, lat);
                        });
                    }
                });
            }

            // Check camp names for more comprehensive bounds
            if (campNames) {
                campNames.features.forEach(feature => {
                    if (feature.geometry.type === 'LineString') {
                        feature.geometry.coordinates.forEach(coord => {
                            const [lon, lat] = coord;
                            minLon = Math.min(minLon, lon);
                            maxLon = Math.max(maxLon, lon);
                            minLat = Math.min(minLat, lat);
                            maxLat = Math.max(maxLat, lat);
                        });
                    }
                });
            }

            return { minLon, maxLon, minLat, maxLat };
        }

        // Fit all data in the viewport
        function zoomToFit() {
            // Calculate bounds from actual loaded data
            const bounds = calculateDataBounds();

            // Fall back to predefined bounds if no data is loaded
            if (!isFinite(bounds.minLon)) {
                bounds.minLon = BRC_BOUNDS.minLon;
                bounds.maxLon = BRC_BOUNDS.maxLon;
                bounds.minLat = BRC_BOUNDS.minLat;
                bounds.maxLat = BRC_BOUNDS.maxLat;
            }

            // Calculate the scale needed to fit the bounds in the canvas
            const latRange = bounds.maxLat - bounds.minLat;
            const lonRange = bounds.maxLon - bounds.minLon;

            const latScale = Math.cos(((bounds.maxLat + bounds.minLat) / 2) * Math.PI / 180);

            const scaleX = (canvas.width * 0.9) / (lonRange * latScale);
            const scaleY = (canvas.height * 0.9) / latRange;

            viewport.scale = Math.min(scaleX, scaleY);
            viewport.centerX = (bounds.maxLon + bounds.minLon) / 2;
            viewport.centerY = (bounds.maxLat + bounds.minLat) / 2;

            redraw();
        }

        // Toggle functions
        function toggleNames() {
            showNames = !showNames;
            redraw();
        }

        function toggleOutlines() {
            showOutlines = !showOutlines;
            redraw();
        }

        // Mouse panning state
        let isPanning = false;
        let lastMousePos = { x: 0, y: 0 };

        // Mouse event handlers for panning
        canvas.addEventListener('mousedown', (e) => {
            isPanning = true;
            const rect = canvas.getBoundingClientRect();
            lastMousePos.x = e.clientX - rect.left;
            lastMousePos.y = e.clientY - rect.top;
            canvas.style.cursor = 'grabbing';
        });

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const canvasX = e.clientX - rect.left;
            const canvasY = e.clientY - rect.top;

            if (isPanning) {
                // Calculate the difference in mouse position
                const deltaX = canvasX - lastMousePos.x;
                const deltaY = canvasY - lastMousePos.y;

                // Convert canvas pixel movement to geographic coordinate movement
                const latScale = Math.cos(viewport.centerY * Math.PI / 180);
                const deltaLon = -deltaX / (viewport.scale * latScale);
                const deltaLat = deltaY / viewport.scale;

                // Update viewport center
                viewport.centerX += deltaLon;
                viewport.centerY += deltaLat;

                // Update last mouse position
                lastMousePos.x = canvasX;
                lastMousePos.y = canvasY;

                // Redraw the map
                redraw();
            }

            // Update coordinate display and camp detection
            const geo = canvasToGeo(canvasX, canvasY);
            document.getElementById('coordinates').textContent =
                `Mouse: ${geo.lon.toFixed(6)}, ${geo.lat.toFixed(6)}`;

            // Check if mouse is over a camp (only when not panning)
            if (!isPanning) {
                const newHighlightedCamp = findCampAtLocation(geo.lon, geo.lat);

                if (newHighlightedCamp !== highlightedCamp) {
                    highlightedCamp = newHighlightedCamp;

                    // Update camp display and diagnostic information
                    const campDisplay = document.getElementById('currentCamp');
                    const diagnosticDisplay = document.getElementById('diagnostic');
                    
                    if (highlightedCamp && highlightedCamp.properties && highlightedCamp.properties.fid) {
                        campDisplay.textContent = `Camp: ${highlightedCamp.properties.fid}`;
                        diagnosticDisplay.style.display = 'none';
                    } else {
                        campDisplay.textContent = 'Camp: None';
                        if (lastDiagnostic) {
                            diagnosticDisplay.textContent = lastDiagnostic;
                            diagnosticDisplay.style.display = 'inline-block';
                        } else {
                            diagnosticDisplay.style.display = 'none';
                        }
                    }

                    redraw();
                }
            }
        });

        canvas.addEventListener('mouseup', (e) => {
            isPanning = false;
            canvas.style.cursor = 'crosshair';
        });

        // Handle mouse leaving the canvas area
        canvas.addEventListener('mouseleave', (e) => {
            isPanning = false;
            canvas.style.cursor = 'crosshair';

            // Clear camp highlighting when mouse leaves
            if (highlightedCamp) {
                highlightedCamp = null;
                document.getElementById('currentCamp').textContent = 'Camp: None';
                document.getElementById('diagnostic').style.display = 'none';
                redraw();
            }
        });

        // Zoom functionality
        function zoomAtPoint(canvasX, canvasY, zoomFactor) {
            // Get the geographic coordinates at the mouse position before zooming
            const geoBeforeZoom = canvasToGeo(canvasX, canvasY);

            // Apply the zoom
            viewport.scale *= zoomFactor;

            // Constrain zoom levels to reasonable bounds
            const minScale = 100;   // Very zoomed out
            const maxScale = 500000; // Very zoomed in
            viewport.scale = Math.max(minScale, Math.min(maxScale, viewport.scale));

            // Get the geographic coordinates at the same canvas position after zooming
            const geoAfterZoom = canvasToGeo(canvasX, canvasY);

            // Adjust the viewport center to keep the mouse position fixed
            viewport.centerX += geoBeforeZoom.lon - geoAfterZoom.lon;
            viewport.centerY += geoBeforeZoom.lat - geoAfterZoom.lat;

            redraw();
        }

        // Mouse wheel zoom handler
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault(); // Prevent page scrolling

            const rect = canvas.getBoundingClientRect();
            const canvasX = e.clientX - rect.left;
            const canvasY = e.clientY - rect.top;

            // Calculate zoom factor from wheel delta
            // Normalize the wheel delta for cross-browser compatibility
            let deltaY = e.deltaY;
            if (e.deltaMode === 1) { // DOM_DELTA_LINE
                deltaY *= 40;
            } else if (e.deltaMode === 2) { // DOM_DELTA_PAGE
                deltaY *= 400;
            }

            // Smooth zoom factor calculation
            const zoomSpeed = 0.001;
            const zoomFactor = Math.exp(-deltaY * zoomSpeed);

            zoomAtPoint(canvasX, canvasY, zoomFactor);
        }, { passive: false });

        // Touch/trackpad gesture support for pinch-to-zoom
        let lastTouchDistance = 0;
        let touchCenter = { x: 0, y: 0 };

        canvas.addEventListener('touchstart', (e) => {
            if (e.touches.length === 2) {
                // Calculate initial distance between two touches
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                const rect = canvas.getBoundingClientRect();

                const dx = (touch1.clientX - touch2.clientX);
                const dy = (touch1.clientY - touch2.clientY);
                lastTouchDistance = Math.sqrt(dx * dx + dy * dy);

                // Calculate center point of the two touches
                touchCenter.x = (touch1.clientX + touch2.clientX) / 2 - rect.left;
                touchCenter.y = (touch1.clientY + touch2.clientY) / 2 - rect.top;

                e.preventDefault();
            }
        }, { passive: false });

        canvas.addEventListener('touchmove', (e) => {
            if (e.touches.length === 2 && lastTouchDistance > 0) {
                // Calculate current distance between two touches
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                const rect = canvas.getBoundingClientRect();

                const dx = (touch1.clientX - touch2.clientX);
                const dy = (touch1.clientY - touch2.clientY);
                const currentDistance = Math.sqrt(dx * dx + dy * dy);

                // Calculate zoom factor from distance change
                const zoomFactor = currentDistance / lastTouchDistance;

                // Update center point
                touchCenter.x = (touch1.clientX + touch2.clientX) / 2 - rect.left;
                touchCenter.y = (touch1.clientY + touch2.clientY) / 2 - rect.top;

                zoomAtPoint(touchCenter.x, touchCenter.y, zoomFactor);

                lastTouchDistance = currentDistance;
                e.preventDefault();
            }
        }, { passive: false });

        canvas.addEventListener('touchend', (e) => {
            if (e.touches.length < 2) {
                lastTouchDistance = 0;
            }
        });

        // Handle window resize
        window.addEventListener('resize', resizeCanvas);

        // Start the application
        init();
    </script>
</body>

</html>